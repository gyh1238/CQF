# CQF ‚Äì Continuous-valued Quantum Framework for Network Assignment  
*A universal quantum framework for inter-/intra-cell resource optimisation*

> **Paper:** ‚ÄúA Universal Quantum Framework for Assignment Optimisation in  
> Network Administration‚Äù (IEEE X, 20xx)  
> **Authors:** Yong Hun Jang ¬∑ Junyoung Hwang ¬∑ Wookjin Lee ¬∑ Sang Hyun Lee

> **Version note**  
> This repository contains code compatible with **Qiskit ‚â• 1.0** (tested on 1.1).  
> Legacy support for Qiskit 0.46 is archived separately.

---

## 1. Overview: What is CQF?

CQF implements a gate-level quantum workflow for solving two key network management problems:

1. **Inter-cell user association** ‚Äì Assign each User Equipment (UE) to the most suitable Access Point (AP), while enforcing access limits.
2. **Intra-cell resource block (RB) allocation** ‚Äì Allocate RBs to UEs within the same AP to maximize total throughput.

A classical brute-force search requires evaluating all \|ùê∂\| = M<sup>N</sup> configurations.  
CQF reduces this complexity using **amplitude amplification**, requiring only  
**O(‚àö(\|ùê∂\|‚ÅÑ\|ùêπ\|))** iterations.

This is achieved by:
- Encoding real-valued metrics (e.g., power, rate) directly into **qubit phases**.
- Enforcing combinatorial constraints using modular oracles.

---

## 2. CQF Architecture

The CQF pipeline consists of the following components:

- Classical Preprocessing
- Qubit/State Preparation
- Access/Resource Limit Constraint Oracle
- Objective Oracle
- Diffusion
- Measurement
- Classical Postprocessing

The following diagram illustrates the architecture of the CQF framework:

<div align="center"> <img src="fig/fig2_quantum_flow.png" width="1000"/> <br><em>Fig 2 ‚Äì Quantum optimization loop used in CQF</em> </div>

---

## 3. Repository Layout

```text
CQF/
‚îú‚îÄ‚îÄ fig/                # All figures used in the paper and extended results
‚îÇ   ‚îú‚îÄ‚îÄ fig1_network_overview.png
‚îÇ   ‚îú‚îÄ‚îÄ fig2_quantum_flow.png
‚îÇ   ‚îú‚îÄ‚îÄ fig3_qubit_encoding.png
‚îÇ   ‚îú‚îÄ‚îÄ fig4_access_limit_oracles.png
‚îÇ   ‚îú‚îÄ‚îÄ fig5_phase_rotation.png
‚îÇ   ‚îú‚îÄ‚îÄ fig6_performance_korea_map.png
‚îÇ   ‚îú‚îÄ‚îÄ inter_circuit.png
‚îÇ   ‚îú‚îÄ‚îÄ intra_circuit.png
‚îÇ   ‚îú‚îÄ‚îÄ inter_histogram.png
‚îÇ   ‚îî‚îÄ‚îÄ intra_histogram.png
‚îú‚îÄ‚îÄ qiskit>=1.0/             # Main implementation (Qiskit ‚â• 1.0)
‚îÇ   ‚îú‚îÄ‚îÄ inter_assignment_qiskit1.1.ipynb
‚îÇ   ‚îî‚îÄ‚îÄ intra_assignment_qiskit1.1.ipynb
‚îú‚îÄ‚îÄ qiskit<1.0/             
‚îÇ   ‚îú‚îÄ‚îÄ inter_cell_assignment_access_limit_only.ipynb
‚îÇ   ‚îú‚îÄ‚îÄ inter_cell_assignment_objective.ipynb
‚îÇ   ‚îú‚îÄ‚îÄ intra_cell_assignment_1_objective_aux.ipynb
‚îÇ   ‚îî‚îÄ‚îÄ intra_cell_assignment_3_objective_aux.ipynb
‚îî‚îÄ‚îÄ README.md
````

---

## 4. Five-Step Workflow

| #     | Function / Cell                 | What happens                                                                                             |
| ----- | ------------------------------- | -------------------------------------------------------------------------------------------------------- |
| **1** | `generate_problem`              | Build or load cost / power matrices, AP limits, etc.                                                     |
| **2** | `encode_state`                  | Allocate the *state register* (`N √ó ‚åàlog‚ÇÇM‚åâ` qubits) and auxiliary qubits.                                |
| **3** | `oracle.*`                      | (a) flip the aux qubit if a configuration is **feasible**<br>(b) add a cost-proportional **phase kick**. |
| **4** | `run_amplitude_amplification`   | Apply the oracle ‚Üí diffuser loop ‚åäœÄ‚ÅÑ4 ‚àö(\|ùê∂\|‚ÅÑ\|ùêπ\|)‚åã times.                                             |
| **5** | `decode_counts`                 | Map the most frequent bitstring back to UE‚ÜîAP or UE‚ÜîRB indices.                                          |

---

## 5. Visual Explanation of the Code (Backed by Figures)

This framework is not just theoretical ‚Äî it produces measurable quantum outputs and interpretable results. Each notebook generates figures like those below. These figures explain what the code is doing at every stage.


### Quantum Circuits: What was actually run?

The actual Qiskit circuits generated by the notebooks include:
- State preparation
- Constraint enforcement via oracles
- Cost-aware phase rotation
- Amplitude amplification loop

This figure shows the quantum circuit constructed in the `q_circuit()` function:

<div align="center">
  <img src="fig/inter_circuit.png" width="700"/>
  <br><em>fig/inter_circuit.png ‚Äî Circuit for inter-cell assignment with access limit oracle</em>
</div>

<div align="center">
  <img src="fig/intra_circuit.png" width="700"/>
  <br><em>fig/intra_circuit.png ‚Äî The first half of circuit for intra-cell RB allocation with exclusivity enforced</em>
</div>

<!--
These circuits are generated by calling:

```python
qc = build_access_limit(qc, state, aux, limit=2)
qc = build_phase_oracle(qc, state, cost_matrix, p_min, p_max)
````

You can swap in your own constraints or cost models by editing `oracle.py` or `phase_utils.py`.
-->

### Sampling Histograms: What did the quantum circuit return?

Each run samples the quantum register thousands of times. These histograms show the distribution of measured bitstrings.

This histogram displays the output probabilities after executing the quantum circuit:
 
<div align="center">
  <img src="fig/inter_histogram.png" width="400"/>
  <br><em>fig/inter_histogram.png ‚Äî Output counts for inter-cell assignment (bitstrings ‚Üí UE-AP mapping)</em>
</div>

<div align="center">
  <img src="fig/intra_histogram.png" width="400"/>
  <br><em>fig/intra_histogram.png ‚Äî Output counts for intra-cell assignment (bitstrings ‚Üí UE-RB mapping)</em>
</div>

Each spike corresponds to a feasible configuration. The most frequent one is typically optimal or very close to it.

---

### Summary

| File                           | Output                                                            |
| ------------------------------ | ----------------------------------------------------------------- |
| `inter_cell_assignment*.ipynb` | `inter_histogram.png`, `inter_circuit.png`, `inter_dt_result.png` |
| `intra_cell_assignment*.ipynb` | `intra_histogram.png`, `intra_circuit.png`, `intra_dt_result.png` |

Every figure here is auto-generated by running the corresponding notebook. You can plug in your own cost matrix and constraints, and everything updates automatically.

---

<!--

## 6. Quick Start

```bash
git clone https://github.com/gyh1238/CQF.git
cd CQF

conda create -n cqf python=3.12       # or use venv/poetry
conda activate cqf
pip install "qiskit>=1.1" jupyterlab matplotlib

jupyter lab qiskit/inter_cell_assignment.ipynb
```

Change problem size in the first cell (`PROBLEM_SIZE = {...}`) and press **Run All**.

---

## 7. Drop-in Example

```python
from qiskit_oracle.oracle import build_access_limit, build_phase_oracle
from qiskit_oracle.driver import encode_state, run_amplitude_amplification, decode_counts

state, aux, qc = encode_state(num_ue=5, num_ap=2)
qc = build_access_limit(qc, state, aux, limit=2)
qc = build_phase_oracle(qc, state, cost_matrix, p_min, p_max)

amplified = run_amplitude_amplification(qc)
counts = amplified.simulate(shots=8192).get_counts()
best   = decode_counts(counts)[0]     # list of UE‚ÜíAP indices
print(best)
```

Swap in your own `cost_matrix` and you have a ready-made quantum optimiser.

---

-->

## 6. Glossary

| Term           | Meaning                                                       |
| -------------- | ------------------------------------------------------------- |
| **UE**         | User Equipment (handset, laptop, ‚Ä¶)                           |
| **AP**         | Access Point (cell)                                           |
| **RB**         | Resource Block                                          |
| **Oracle**     | Quantum circuit that marks feasible states (and adds a phase) |
| **Phase kick** | Rotate \|œà‚ü© by œÜ ‚àù cost                                       |

---

## 7. Paper in One Paragraph

The accompanying paper formalises the continuous-valued assignment problem as a phase-encoded search and proves that the proposed oracle structure achieves a quadratic speed-up over exhaustive search while preserving solution optimality under noisy, real-valued link metrics. *If you just want to solve real networks, the code above is all you need if you need proofs, read the PDF.*

---

## 8. Reproducing the Paper Figures

| Figure               | Contents                         | Generated from           |
| -------------------- | -------------------------------- | ------------------------ |
| Fig 1‚Äì5              | Conceptual illustrations         | Pre-drawn in Illustrator |
| Fig 6                | Campus simulation results        | inter/intra notebooks    |
| inter\_circuit.png   | Gate-level circuit (inter-cell)  | auto-generated           |
| intra\_circuit.png   | Gate-level circuit (intra-cell)  | auto-generated           |
| inter\_histogram.png | Output distribution (inter-cell) | from sampling            |
| intra\_histogram.png | Output distribution (intra-cell) | from sampling            |

---

## 9. Results and Visualization

CQF achieves high fidelity in both problems:

| Task                               | ‚â§5% deviation |
| ---------------------------------- | ------------- |
| Inter-cell power minimization      | 98.6%         |
| Intra-cell throughput maximization | 96.8%         |

### Inference Histograms

<div align="center">
  <img src="fig/inter_histogram.png" width="380"/>
  <img src="fig/intra_histogram.png" width="380"/>
  <br><em>Measured output bitstrings ‚Äì inter-cell assignment / intra-cell assignment</em>
</div>

### Accuracy Compared to Baseline

The figures below compare the proposed quantum algorithm‚Äôs solution quality to quantized quantum baselines.
<div align="center">
  <img src="fig/intra_dt_result.png" width="380"/>
  <img src="fig/inter_dt_result.png" width="380"/>
  <br><em>fig/intra_dt_result.png and fig/inter_dt_result.png ‚Äî % of solutions within X% of optimal</em>
</div>

* Blue bars: This framework
* Orange bars: Quantized Quantum method

Over 95% of quantum outputs fall within 5% of the global optimum.

### Assignment Outputs (With Digital Twin Implementation)

The quantum algorithm solves both **inter-cell** (user-to-AP) and **intra-cell** (RB-to-user) problems.

<p align="center">
  <img src="fig/fig6_performance_map.png" width="700"/>
  <br><em>Simulation results for X University campus deployment</em>
</p>

- Bottom left: Inter-cell assignment minimizes total power across APs under capacity limits.
- Top right: Intra-cell assignment maximizes total throughput to multiple UEs sharing an AP.
- Right panels: Histograms show how often the quantum algorithm outputs near-optimal solutions.

## 10. Complexity

This section summarizes the asymptotic and measured runtime models we use in CQF for a system with **N users** and **M access points** (we use the common regime **M ‚âà N/10**). Unless noted otherwise, all logarithms are base‚Äë2.

### 1) Empirical scaling (trendline fits)

We fit simple trendlines (units: **nanoseconds**) to the log‚Äìlog curves obtained from our experiments. These capture practical constants while preserving the dominant growth rates.

* **Proposed runtime (baseline):**
  $t = 126.63 N\log N + 4031 (\text{ns})$
* **Proposed runtime (enhanced):**
  $t = 31.63 N\log N + 1008 (\text{ns})$
* **Quantized baseline:**
  $t = 9.98 N^{2}\log\log 0.1N - 27.4N + 1196 (\text{ns})$
* **Classical (Hungarian, cubic fit):**
  $t = 0.182 N^{3} (\text{ns})$

**Interpretation.** The proposed methods scale like **O(Nlog N)** and stay below the quantized **O(N¬≤loglog N)** and classical **O(N¬≥)** baselines beyond modest M. See the left plot for the fitted curves on log‚Äìlog axes.

![Empirical scaling](fig/fig_complex_UE.png)

> **Axes.** Horizontal: users (N). Vertical: runtime in seconds (shown on a relative/log scale). We evaluate under the regime M ‚âà N/10.

### 2) Exact gate‚Äëcount model ‚Üí t‚Äëdepth √ó quantum cycle time

For the quantum versions we also provide an exact model derived from gate‚Äëlevel **t‚Äëdepth** multiplied by a **quantum cycle time** $\tau$. We use $\tau = 50\text{ns}$ for the baseline and a reduced constant for the enhanced pipeline.

* **Proposed runtime (baseline):**
  $t = 50\text{ns}\Big[ 2N\log N + 2N\log M + 2\log N + 2\log M + \log(N\log M) \Big]$

* **Proposed runtime (enhanced / pipelined):**
  $t = 12.5\text{ns}\Big[ 2N\log N + 2N\log M + 2\log N + 2\log M + \log(N\log M) \Big]$
  The enhanced line uses the same depth expression but a smaller effective cycle time (e.g., deeper parallelism/pipelining), giving a $\times4$ constant‚Äëfactor improvement.

* **Quantized baseline:**
  $t = 50\text{ns}\Bigg[ \frac{(N^{2}-N)}{s}\log\log\!\left(\tfrac{N}{10}\right) \Bigg]$
  Here $s \sim$ the rate at which circuit depth decreases when additional qubits are used. In practice, $s$ cannot grow arbitrarily: hardware parallelization limits and error-correction overheads cap the benefit. A value of $s=5$ is typically taken as a reasonable balance point between qubit overhead and depth reduction.

* **Classical (Hungarian):**
  $t = \alpha N^{3}$
  where $\alpha$ is fitted for a reference machine (\~48 cores @ 3.5 GHz, \~90 GB/s memory BW), to overlay the dashed curve in the plot below.

#### Notes & assumptions

* Regime: **N ‚âà M/10** throughout the figures.
* Logarithms are base‚Äë2 constant terms inside logs reflect register sizing and control.
* Units on the vertical axis are seconds (log scale) formulas above show **ns** coefficients to match cycle‚Äëlevel models.
* The enhanced curve reflects improved constant factors via parallel organization the asymptotic order remains **O(N log N)**.

---

### How we derive these formulas (gate model ‚Üí t-depth ‚Üí runtime)

We count Clifford+T under the **relative-phase Toffoli** model (4 T, T-depth 1).
Let **N** = #UEs, **M** = #APs, **k** = ‚åàlog‚ÇÇM‚åâ (address bits), **w** = ‚åàlog‚ÇÇ(N+1)‚åâ (per-AP counter width), **œÑ** = quantum cycle time, **œÑ(Œµ)** = synthesis cost for one controlled phase.

**Parallelism assumption (per-AP lanes).** Allocate **$M$** extra ancilla qubits (one lane-enable per AP). With lanes, **all AP-local work runs in parallel across APs** within each AP, updates over the $N$ users run sequentially (ripple increments).

#### A) Oracle (access-limit check + mark)

1. **(u,a) flag, $[\mathrm{sel}_u=a]$**
   k-input AND via a Toffoli tree, do+uncompute ‚Üí **$2(k-1)$** Toffoli per flag. Across all $NM$ flags:

$$
T_{\text{flag}}=8NM(k-1).
$$

Depth for all flags in parallel across APs (per user $u$): balanced Toffoli tree height with do+uncompute:

$$
D_{\text{flag}} = 2\left\lceil \log_2 k \right\rceil .
$$

2. **Conditional +1 into AP counter (width $w$)**
   Per increment ‚âà **$2w-1$** Toffoli (no reverse of the increment itself). Over all $(u,a)$:

$$
T_{\text{inc}}=8NMw - 4NM.
$$

With AP lanes, each AP performs $N$ ripple increments serially (parallel across APs):

$$
D_{\text{inc}} = N(2w-1).
$$

3. **Per-AP limit compare $(\le U_a)$, global AND, mark**
   Per-AP compare (do+undo) ‚âà $2w$ Toffoli ‚Üí **$8w$** T-count per AP AND of the $M$ results (do+undo) via balanced tree ‚Üí $2(M-1)$ Toffoli ‚Üí **$8(M-1)$**:

$$
T_{\text{limit}} = 8Mw + 8(M-1).
$$

Depth (comparators parallel across APs, then a tree AND):

$$
D_{\text{cmp}} = 2w, \qquad
D_{\text{AND}} = 2\left\lceil \log_2 M \right\rceil .
$$

4. **Optional weight phases**

$$
T_{\text{wt}}=NM\cdot\tau(\varepsilon), \qquad
D_{\text{wt}} \approx 1.
$$

**Oracle totals (no asymptotic compression):**

$$
\boxed{
T_{\text{oracle}} \=\ 8NM(k+w)\+ 8Nw\+ 8(N-1)\+ NM\tau(\varepsilon)
}
$$

$$
\boxed{
D_{\text{oracle}} \=\ \underbrace{2\lceil\log_2 k\rceil}_{\text{flags}}
\+\\underbrace{N(2w-1)}_{\text{increments}}
\+\\underbrace{2w}_{\text{per-AP compares}}
\+\\underbrace{2\lceil\log_2 M\rceil}_{\text{global AND}}
\+\\underbrace{1}_{\text{weight phases}}
}
$$

#### B) Diffusion (Grover reflection)

On the $Nk$-bit selection register:

$$
\boxed{
T_{\text{diff}} \=\ c_{\text{diff}}(N k)
}
$$

$$
\boxed{
D_{\text{diff}} \=\ \left\lceil \log_2(Nk) \right\rceil
\=\ \left\lceil \log_2 N + \log_2 k \right\rceil
}
$$

#### C) Oracle **+** Diffusion (no abbreviation)

$$
\boxed{
T_{\text{total}} \=\
\underbrace{8NM(k+w)}_{\text{flags+inc main}}
\+\\underbrace{8Nw}_{\text{counter tails}}
\+\\underbrace{8(N-1)}_{\text{flag tails}}
\+\\underbrace{NM\tau(\varepsilon)}_{\text{weight phases}}
\+\\underbrace{c_{\text{diff}}Nk}_{\text{diffusion}}
}
$$

$$
\boxed{
\begin{aligned}
D_T \=\&
\underbrace{2\lceil\log_2 k\rceil}_{\text{flag trees}}
\+\\underbrace{N(2w-1)}_{\text{per-AP ripple increments}}
\+\\underbrace{2w}_{\text{per-AP compares}}
\+\\underbrace{2\lceil\log_2 M\rceil}_{\text{global AND}}
\+\\underbrace{1}_{\text{weight phases}}\\
&\+\\underbrace{\lceil \log_2(Nk) \rceil}_{\text{diffusion}}
\end{aligned}
}
$$

**Runtime rule.** Treating Clifford cost as \~0, the runtime for one full iteration (oracle + diffusion) is

$$
\boxed{t \\simeq\ D_T \cdot \tau},
$$

with $D_T$ exactly as written above.


#### Mapping to the plotted formulas

* **Exact model plot.** Substitute `k ‚âà log‚ÇÇM`, `w ‚âà log‚ÇÇN`, balance the trees, and keep only depth‚Äëcontributing terms ‚Üí
  `D_T ‚âà 2N¬∑log N + 2N¬∑log M + 2¬∑log N + 2¬∑log M + log(N¬∑log M)`.
  The last term comes from diffusion over a register of size `Nk`. Multiply by `œÑ = 50 ns` (baseline) for the blue curve the **enhanced** curve multiplies the same depth by `œÑ = 12.5 ns` to reflect a 4√ó constant‚Äëfactor improvement (pipelining/parallel scheduling).
* **Trendline plot.** Fit `t = a¬∑N¬∑log N + b` (ns) to the exact‚Äëmodel points. With `M ‚âà N/10`, `log M ‚âÉ log N ‚àí log 10` is absorbed into the constant and linear‚Äëin‚Äëlog terms. This yields the reported coefficients (e.g., 126.63 and 31.63 for baseline/enhanced).
* **Quantized baseline.** Use analytic driver `(N¬≤‚àíN)/s¬∑log log M`, multiply by `50 ns`. with s =5.
* **Classical.** Use `t =  Œ±¬∑N¬≥`, with `Œ±` fitted on a reference workstation to overlay the dashed curve.

> Using **standard Toffoli (7 T)** instead of relative‚Äëphase Toffoli scales all T‚Äëcounts by **7/4** depths stay the same up to constants.

---

# 11. Hardware-Aware Experiments and Evaluation

We evaluate circuits under realistic device assumptions rather than idealized simulation. When available, experiments target IBM Quantum backends; otherwise, we use Qiskit Aer with calibrated noise and timing that mirror NISQ conditions. Device behavior (T1/T2, gate/readout errors) is taken from backend properties and varies with daily calibration.

### Hardware realism

* **Connectivity & routing.** Transpilation is topology- and noise-aware; routing overhead is reported explicitly. Because routing can appear as **SWAP gates** *or* as **bridge/CX chains**, we report both **SWAP count** and **total two-qubit gates**.
* **Scheduling & timing.** Circuits are **scheduled with backend instruction durations** (dt-based), reflecting gate/measurement timing used by Aer noise models derived from device calibrations.
* **Virtual-Z.** Phase updates are modeled as **frame changes with zero duration** (they do not increase scheduled depth). We acknowledge their presence after decomposition but do **not** report them numerically.
* **Noise (simulator).** Aer device-noise models incorporate **gate error**, **gate length**, **T1/T2**, and **readout error** from device properties; hardware runs rely on the backend‚Äôs properties at execution time.

### Error-mitigation knobs

* **Dynamic decoupling (DD).** Even-length sequences inserted on idle windows after scheduling (when schedulable).
* **Relative-phase Toffoli.** Multi-controlled operations prefer relative-phase variants to reduce non-Clifford cost and depth.
* **Readout mitigation & virtual-Z corrections.** Readout-error mitigation via Runtime/Aer options; virtual-Z phase updates incur no extra gate time.

### Metrics reported per experiment

* **Qubits used.**
* **Depth** (scheduled), **with/without DD**.
* **Routing cost:** **SWAP count** and **total two-qubit gates** (e.g., `cx`, `cz`, `ecr`, `swap`).
* **Distribution shift:** total variation distance between no-DD and DD outputs (when applicable).
* *(When running on hardware)* **Device snapshot:** T1/T2 and two-qubit/measurement error samples at execution time.

### Interpreting results

* **DD on vs off.** DD can slightly increase depth but improve quality when dephasing dominates; the effect can be neutral for short circuits or mild noise.
* **Routing overhead.** Higher two-qubit counts or SWAPs indicate connectivity-driven cost. Note that **SWAP = 0** does **not** imply ‚Äúno routing‚Äù if bridges increased the two-qubit count.
* **Virtual-Z.** Frame changes absorb many phase adjustments; they **do not** increase scheduled depth and are not reported as a numeric metric.

---

# 12. Resource & Runtime Log

We report circuit resources right after construction (**raw**) and after transpilation for the Aer simulator (**transpiled**, optimization level = 1). Logged items include **qubits**, **depth**, **total gate counts** (with **SWAPs**), and **top operations** by count.

---

#### Intra-cell (Aer + target backend snapshot)

**Run context**

* **Backend:** `ibm_torino` (us-east)
* **Date (UTC):** 2025-02-21 10:30
* **Transpile:** `opt_level=1`, layout=`sabre`, routing=`sabre`, scheduling=`ALAP`
* **Shots:** 1000 (queue-inclusive wall-clock: **126 s**)

**Calibration snapshot**

* **Qubit sample (q0‚Äìq4):**

  * q0: **T1 210 ¬µs**, **T2 130 ¬µs**, **readout-err 1.0%**
  * q1: **T1 190 ¬µs**, **T2 120 ¬µs**, **readout-err 1.2%**
  * q2: **T1 230 ¬µs**, **T2 140 ¬µs**, **readout-err 0.9%**
  * q3: **T1 170 ¬µs**, **T2 110 ¬µs**, **readout-err 1.4%**
  * q4: **T1 250 ¬µs**, **T2 160 ¬µs**, **readout-err 1.1%**
* **Two-qubit (CX/ECR) error samples:** **0.2‚Äì0.5%**
* **Single-qubit (SX/X) error (avg):** **0.02‚Äì0.1%**

**Resource summary**

* **Qubits:** raw **18** ‚Üí transpiled **18**
* **Depth:** raw **137** ‚Üí transpiled **123**
* **Gates:** raw **276** ‚Üí transpiled **225** (**SWAPs ‚âà 12**)
* **Top ops (transpiled):** `x:65`, `ccx:54`, `cx:40`, `reset:18`, `cry:18`, `u2:17`, `measure:6`, `mcx:4`

**Mitigation used:** noise-aware transpilation (layout/routing matched to device topology and error profile), relative-phase Toffoli, readout-error mitigation, (schedulable) dynamical decoupling, virtual-Z.

---

#### Inter-cell (Aer + target backend snapshot)

**Run context**

* **Backend:** `ibm_torino` (us-east)
* **Date (UTC):** 2025-02-21 11:05
* **Transpile:** `opt_level=1`, layout=`sabre`, routing=`sabre`, scheduling=`ALAP`
* **Shots:** 1000 (queue-inclusive wall-clock: **88 s**)

**Calibration snapshot**

* **Qubit sample (q0‚Äìq4):**

  * q0: **T1 200 ¬µs**, **T2 125 ¬µs**, **readout-err 1.1%**
  * q1: **T1 185 ¬µs**, **T2 115 ¬µs**, **readout-err 1.3%**
  * q2: **T1 240 ¬µs**, **T2 150 ¬µs**, **readout-err 0.9%**
  * q3: **T1 160 ¬µs**, **T2 105 ¬µs**, **readout-err 1.5%**
  * q4: **T1 220 ¬µs**, **T2 135 ¬µs**, **readout-err 1.0%**
* **Two-qubit (CX/ECR) error samples:** **0.2‚Äì0.5%**
* **Single-qubit (SX/X) error (avg):** **0.02‚Äì0.1%**

**Resource summary**

* **Qubits:** raw **10** ‚Üí transpiled **10**
* **Depth:** raw **51** ‚Üí transpiled **38**
* **Gates:** raw **141** ‚Üí transpiled **106** (**SWAPs ‚âà 6**)
* **Top ops (transpiled):** `x:48`, `cry:16`, `mcx:14`, `reset:10`, `u2:7`, `h:4`, `measure:4`, `barrier:1`

**Mitigation used:** noise-aware transpilation (layout/routing matched to device topology and error profile), relative-phase Toffoli, readout-error mitigation, (schedulable) dynamical decoupling, virtual-Z.

---

## 12. Citation

If you use CQF in your research, please cite the following article:

```bibtex
@article{jang2025cqf,
  title   = {A Universal Quantum Framework for Assignment Optimization in Network Administration},
  author  = {Yong Hun Jang, Junyoung Hwang, Wookjin Lee  and Sang Hyun Lee},
  journal = {IEEE X},
  year    = {20xx}
}
```

---

## 12. Contact

For questions or contributions, open an issue or contact:
üìß **[gyh1237@gmail.com](mailto:gyh1237@gmail.com)**

---

**Citations**
IBM docs on properties & calibration and Aer noise modeling (definitions, variability, and how to fetch/use them).

[1]: https://quantum.cloud.ibm.com/docs/api/qiskit-ibm-runtime/0.25/ibm-backend "IBMBackend (v0.25) | IBM Quantum Documentation

[2]: https://qiskit.github.io/qiskit-aer/tutorials/2_device_noise_simulation.html "Device backend noise model simulations - Qiskit Aer 0.17.1

[3]: https://quantum.cloud.ibm.com/docs/guides/error-mitigation-and-suppression-techniques Error mitigation and suppression techniques

[4]: https://quantum.cloud.ibm.com/docs/guides/calibration-jobs Calibration jobs | IBM Quantum Documentation

[5]: https://quantum.cloud.ibm.com/docs/guides/get-qpu-information Get backend information with Qiskit

[6]: Campbell, et al., ‚ÄúApplying quantum algorithms to constraint satisfaction problems,‚Äù Quantum, vol. 3, no. 1, p. 167, 2019.
